# Recorder.ts Refactoring & Extension Plan

## Current Responsibilities (Complexity Analysis)
The `Recorder` class is currently doing too many things, which violates the Single Responsibility Principle:
1.  **State Tracking:** Maintains arrays of `shots` (events) and `states` (table snapshots).
2.  **Logic & Rules Integration:** Interacts with `container.rules` to determine break starts, end of games, and scores.
3.  **URL Generation:** Constructs complex replay and high-score URLs.
4.  **String Processing:** Manages `JSONCrush` compression and custom URI encoding.
5.  **UI Interaction:** Pushes `ChatEvent`s to display links as "pills" in the chat.

## Proposed Refactoring & Improvements

### 1. Extract URL/Encoding Logic
The complex URI encoding and link generation should be moved to a helper or a dedicated class.
- **New Utility:** `src/utils/replay-encoder.ts`
- **Move:** `fullyEncodeURI`, `generateLink`, `generateHiScoreLink`, and `JSONCrush` logic.
- **Why:** This logic is purely about string manipulation and external integration, not recording.

### 2. Extract Link Formatting
The logic for creating the "pills" and determining the icons/colors of links should be moved.
- **New Class:** `src/view/link-formatter.ts`
- **Move:** `lastShotLink`, `breakLink`, `wholeGameLink`.
- **Why:** This is "View" logic. The recorder should just provide the data (the state object); how it's presented to the user should be elsewhere.

### 3. Decouple from Rules
The recorder shouldn't need to know about `isPartOfBreak` or `isEndOfGame` directly.
- **Improvement:** Pass the necessary boolean flags into `updateBreak` instead of the recorder polling the rules.
- **Why:** Makes the recorder easier to test in isolation and less dependent on specific game rule implementations.

### 4. Data Structure Improvement (Postpone)
The parallel `shots` and `states` arrays are brittle.
- **Improvement:** Consider a single `HistoryEntry` interface:
  ```typescript
  interface HistoryEntry {
    state: number[];
    event: GameEvent;
    timestamp: number;
  }
  ```
- **Constraint Check:** This is an internal change; as long as the `state()` method still returns the same JSON structure, the protocol is preserved.


## Multi-player Support (2-Player Mode)

Currently, the recorder only captures events generated by the local player. In 2-player mode, the recorder on each client is incomplete as it misses the opponent's shots.

# Future (Postpone)
### Requirements:
- **Remote Event Capture:** The recorder must be notified when `HitEvent`s are received from the network relay.
- **Watch Controllers Integration:**
    - `WatchAim.handleHit` must call `recorder.record(event)`.
    - `WatchShot.handleStationary` must call `recorder.updateBreak(outcome)`.
- **Game Consistency:** Both players should end the match with an identical `wholeGame()` record.

### Future Strategy:
- **Event Bus:** Transition the `Recorder` to be a passive listener on the `container.eventQueue`. Any `HitEvent`, `RerackEvent`, or `PlaceBallEvent` should be automatically recorded regardless of source (local/remote).

## Preservation of Protocol
To ensure existing replays still work, the output of the following methods must remain IDENTICAL:
- `wholeGame()`
- `lastShot()`
- `currentBreak()`
- `state()` (The private helper that builds the JSON object)

The JSON structure (with keys `init`, `shots`, `start`, `now`, `score`, `wholeGame`, `v`) must not change.

## Logic Extraction Summary
- **Recording Engine:** Keep in `recorder.ts`. Focus on `record()` and `updateBreak()`.
- **Formatting Engine:** Extract to `ReplayLinkView`. Focus on icons (`⚈`, `⚆`), colors, and chat integration.
- **Serialisation Engine:** Extract to `ReplayProtocol`. Focus on `JSONCrush`, `fullyEncodeURI`, and the `state` object construction.

## Testing Required

### 1. Unit Tests (Recorder)
- Verify `record()` correctly pushes state and shot data for `HitEvent` and `RerackEvent`.
- Verify `updateBreak()` correctly calculates break starts and ends based on outcome flags.
- Test `wholeGame()` output against a known valid JSON schema.

### 2. Multi-player Integration Tests
- **Mock Relay Test:** Using `InMemoryMessageRelay`, simulate a shot from Player A and verify Player B's `Recorder` captures the event.

### 3. Regression & Compatibility Tests
- Load a legacy serialised JSON replay into the new system and ensure it plays back correctly.
- Verify `fullyEncodeURI` produces the same output for a set of complex strings (including parentheses and special characters).

# Addendum: Event Bus Migration Plan

The transition to an Event Bus approach will allow the `Recorder` to be a passive observer of the game loop, making it easier to capture both local and remote events consistently.

### Step-by-Step Implementation Plan

1.  **Decouple `record()` from Controllers**:
    Currently, `Aim.playShot` explicitly calls `recorder.record(hitEvent)`. This should be removed in favor of a central hook.

2.  **Enhance `Container.processEvents()`**:
    Modify the event processing loop in `src/container/container.ts` to notify the recorder before an event is applied to the active controller. This ensures the recorder captures the table state *before* it is modified by the event.
    ```typescript
    // In Container.processEvents()
    if (event) {
        this.recorder.record(event);
        this.updateController(event.applyToController(this.controller));
    }
    ```

3.  **Extend `Recorder.record(event)`**:
    Update the `record` method in `src/events/recorder.ts` to handle the following event types:
    -   **`EventType.HIT`**: Push `table.shortSerialise()` to `states` and `event.tablejson.aim` to `shots`.
    -   **`EventType.RERACK`**: Push `table.shortSerialise()` to `states` and the new ball configuration to `shots`.
    -   **`EventType.PLACEBALL`**: (New) Push `table.shortSerialise()` and the placement coordinates. This ensures ball positioning (e.g., in "Ball-in-hand" scenarios) is recorded.

4.  **Preserve Current Protocol**:
    -   The `states` array must continue to store `number[][]` from `table.shortSerialise()`.
    -   The `shots` array must continue to store `GameEvent` objects that the `ReplayEncoder` and `ReplayController` recognize.
    -   Any changes to the internal representation of `RERACK` or `PLACEBALL` in the `shots` array must be reflected in the replay playback logic to avoid breaking legacy replays.

5.  **Enable Remote Recording**:
    Since `BrowserContainer.netEvent` already pushes remote events into the `container.eventQueue`, the passive listener in `Container.processEvents` will automatically record them as they are "played back" locally.

### Verification Steps
-   **Parity Test**: Perform a sequence of shots locally and via a mock network relay; verify that both result in an identical `wholeGame()` JSON output.
-   **Replay Validation**: Ensure that a game recorded via the event bus can be fully replayed using the existing `Replay` controller.