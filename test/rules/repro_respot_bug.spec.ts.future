import { expect } from "chai"
import { Container } from "../../src/container/container"
import { Ball, State } from "../../src/model/ball"
import { Outcome } from "../../src/model/outcome"
import { NineBall } from "../../src/controller/rules/nineball"
import { Assets } from "../../src/view/assets"
import { initDom } from "../view/dom"
import { WatchEvent } from "../../src/events/watchevent"
import { PlaceBallEvent } from "../../src/events/placeballevent"
import { Session } from "../../src/network/client/session"
import { Snooker } from "../../src/controller/rules/snooker"
import { Vector3 } from "three"

initDom()

describe("Reproduction of Respot Bug", () => {
  let container: Container
  let sentEvents: any[] = []

  beforeEach(() => {
    Ball.id = 0
    sentEvents = []
    Session.init("test-client", "TestPlayer", "test-table", false)
    container = new Container(
      undefined,
      (log) => { /* console.log(log) */ },
      Assets.localAssets(),
      "nineball"
    )
    container.broadcast = (event) => {
      sentEvents.push(event)
    }
    container.isSinglePlayer = false
  })

  it("NineBall: should NOT send WatchEvent when 9-ball is respotted after foul", () => {
    const nineball = container.rules as NineBall
    const nineBall = container.table.balls.find((b) => b.label === 9)!
    const cueball = container.table.cueball

    // Simulate foul where 9-ball is potted
    const outcome = [
      Outcome.pot(cueball, 1),
      Outcome.pot(nineBall, 1),
    ]

    nineball.update(outcome)

    // Check sent events
    const watchEvents = sentEvents.filter(e => e instanceof WatchEvent)
    const placeBallEvents = sentEvents.filter(e => e instanceof PlaceBallEvent)

    expect(placeBallEvents).to.have.length(1, "Should send PlaceBallEvent")
    expect(watchEvents).to.have.length(0, "Bug confirmed: NineBall does NOT send WatchEvent for respotting 9-ball")
  })

  it("Ball Serialisation: should NOT preserve state (causing ghost balls in Snooker)", () => {
    const ball = new Ball(new Vector3(1, 2, 0), 0xff0000, 1)
    
    // Test that serialise() omits state
    ball.state = State.InPocket
    const serialised = ball.serialise()
    expect(serialised).to.not.have.property("state")

    // Test that updateFromSerialised ignores state on existing ball
    const existingBall = new Ball(new Vector3(0, 0, 0), 0xff0000, 1)
    existingBall.state = State.InPocket
    
    Ball.updateFromSerialised(existingBall, serialised)
    
    expect(existingBall.pos.x).to.equal(1)
    expect(existingBall.state).to.equal(State.InPocket, "Bug confirmed: State remains InPocket even though ball position was updated from serialised data")
  })

  it("Snooker: should send WatchEvent but state is still missing", () => {
    Ball.id = 0
    container = new Container(
      undefined,
      (log) => {},
      Assets.localAssets(),
      "snooker"
    )
    container.broadcast = (event) => {
      sentEvents.push(event)
    }
    container.isSinglePlayer = false
    const snooker = container.rules as Snooker
    
    // We need to set up the table properly for snooker
    const redBall = container.table.balls.find((b) => b.id >= 7)!
    const yellowBall = container.table.balls.find((b) => b.id === 2)! // Colour
    const cueball = container.table.cueball

    // Simulate foul: hit red first, but pot yellow
    const firstCollision = Outcome.collision(cueball, redBall, 1)
    const outcome = [
      firstCollision,
      Outcome.pot(yellowBall, 1),
    ]

    snooker.update(outcome)

    const watchEvents = sentEvents.filter(e => e instanceof WatchEvent)
    expect(watchEvents).to.have.length(1, "Snooker correctly sends WatchEvent")
    
    const respotEvent = watchEvents[0] as WatchEvent
    expect(respotEvent.json.rerack).to.be.true
    expect(respotEvent.json.balls[0]).to.not.have.property("state", "WatchEvent balls do not have state, confirming the bug still exists in Snooker")
  })
})
