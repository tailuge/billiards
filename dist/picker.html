<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Paintable Icosahedron Sphere</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="stylesheet" href="picker.css" />
</head>

<body>
    <div id="canvas-container">
        <div class="zoom-hint" id="zoom-hint">
            Scroll to zoom â€¢ Drag to rotate
        </div>
    </div>

    <div id="controls">
        <div class="control-group">
            <label>Mode:</label>
            <button id="rotate-btn" class="active">Rotate</button>
            <button id="paint-btn">Paint</button>
        </div>

        <div class="control-group">
            <label>Color:</label>
            <input type="color" id="color-picker" value="#e94560" />
        </div>

        <div class="control-group">
            <label>Detail:</label>
            <input type="range" id="detail-slider" min="0" max="3" value="1" step="1" />
            <span class="slider-value" id="detail-value">1</span>
        </div>

        <div class="control-group">
            <button id="clear-fill-btn">Clear/Fill</button>
        </div>

        <div class="control-group">
            <label>Presets:</label>
            <div class="preset-container">
                <button class="preset-btn" data-ball="1">1</button>
                <button class="preset-btn" data-ball="2">2</button>
                <button class="preset-btn" data-ball="3">3</button>
                <button class="preset-btn" data-ball="4">4</button>
                <button class="preset-btn" data-ball="5">5</button>
                <button class="preset-btn" data-ball="6">6</button>
                <button class="preset-btn" data-ball="7">7</button>
                <button class="preset-btn" data-ball="8">8</button>
                <button class="preset-btn" data-ball="9">9</button>
            </div>
        </div>

        <div class="control-group">
            <button id="dev-toggle">Dev Panel</button>
        </div>

        <div class="control-group">
            <span class="mode-indicator" id="mode-indicator">Rotate Mode</span>
        </div>
    </div>

    <!-- Floating Dev Panel Overlay -->
    <div id="dev-panel-overlay">
        <div id="dev-panel">
            <div id="dev-panel-header">
                <h2>Developer Panel</h2>
                <button id="dev-panel-close">&times;</button>
            </div>
            <div id="dev-panel-content">
                <div class="dev-section" style="flex: 0.4">
                    <h3>Triangle Colors</h3>
                    <div id="triangle-list"></div>
                </div>
                <div class="dev-section" style="flex: 0.6">
                    <h3>Color Array</h3>
                    <textarea id="json-state" readonly></textarea>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Base colors for balls 1-9
        const BALL_BASE_COLORS = [
            "#e0de36", // 1 (Yellow)
            "#0a74c2", // 2 (Blue)
            "#ff0000", // 3 (Red)
            "#3e009c", // 4 (Purple)
            "#ff9d00", // 5 (Orange)
            "#087300", // 6 (Green)
            "#521911", // 7 (Burgundy/Maroon)
            "#050505", // 8 (Black)
            "#e0de36", // 9 (Yellow/Gold)
        ]

        // Ball color presets with small random deviations
        const BALL_PRESETS = {
            1: [
                "#D6D434",
                "#E2E036",
                "#E4E237",
                "#D8D634",
                "#EDEB39",
                "#CCCB31",
                "#F5F23B",
                "#E0DE36",
                "#EAE838",
                "#F0EE3A",
                "#F3F03A",
                "#f0f0f0",
                "#ECEA39",
                "#F2F03A",
                "#f0f0f0",
                "#F0ED3A",
                "#CAC831",
                "#DEDC35",
                "#F3F13B",
                "#E9E638",
                "#CCCB31",
                "#D1CF32",
                "#EEEC39",
                "#DCDA35",
                "#E3E137",
                "#CFCD32",
                "#EAE839",
                "#E9E738",
                "#ECEA39",
                "#E5E337",
                "#E1DF36",
                "#E4E237",
                "#E4E237",
                "#f0f0f0",
                "#f0f0f0",
                "#f0f0f0",
                "#f0f0f0",
                "#f0f0f0",
                "#CECC32",
                "#f0f0f0",
                "#CBC931",
                "#D1CF32",
                "#D0CE32",
                "#DBD935",
                "#E3E137",
                "#D4D233",
                "#F6F43B",
                "#F2F03A",
                "#CDCC32",
                "#F6F43B",
                "#CDCB31",
                "#f0f0f0",
                "#E7E538",
                "#f0f0f0",
                "#f0f0f0",
                "#f0f0f0",
                "#CECC32",
                "#E0DE36",
                "#D7D534",
                "#F2F03A",
                "#E4E237",
                "#D4D233",
                "#D8D634",
                "#E0DE36",
                "#D5D333",
                "#D5D333",
                "#D7D534",
                "#F4F23B",
                "#f0f0f0",
                "#CCCA31",
                "#E6E437",
                "#ECEA39",
                "#f0f0f0",
                "#000000",
                "#000000",
                "#000000",
                "#CCCA31",
                "#E3E137",
                "#CDCB31",
                "#E9E738"
            ],
            2: [
                "#0B7FD4",
                "#0A70BB",
                "#0B7ED3",
                "#0A77C7",
                "#ededed",
                "#ededed",
                "#ededed",
                "#000000",
                "#ededed",
                "#ededed",
                "#000000",
                "#ededed",
                "#0969AF",
                "#0A71BE",
                "#0A72BF",
                "#0B7ACC",
                "#0B7BCE",
                "#0A79CB",
                "#096AB1",
                "#0A79CA",
                "#000000",
                "#ededed",
                "#ededed",
                "#ededed",
                "#096DB7",
                "#0A78C9",
                "#0B7DD1",
                "#0A75C3",
                "#096CB5",
                "#0B7ACC",
                "#0A6FBA",
                "#0A71BC",
                "#0A6FBA",
                "#0A79CA",
                "#0A72BF",
                "#0A78C9",
                "#ededed",
                "#000000",
                "#000000",
                "#000000",
                "#ededed",
                "#ededed",
                "#ededed",
                "#096DB6",
                "#0A72BF",
                "#096BB3",
                "#0A76C6",
                "#0A75C4",
                "#096AB1",
                "#0B7BCE",
                "#096AB1",
                "#0A73C0",
                "#ededed",
                "#ededed",
                "#ededed",
                "#000000",
                "#ededed",
                "#000000",
                "#000000",
                "#ededed",
                "#0B7CCF",
                "#0B7ED2",
                "#ededed",
                "#096CB4",
                "#096CB5",
                "#0A77C8",
                "#0A71BE",
                "#096EB8",
                "#096CB4",
                "#0A76C6",
                "#0B7BCE",
                "#0A74C3",
                "#ededed",
                "#ededed",
                "#ededed",
                "#ededed",
                "#ededed",
                "#ededed",
                "#000000",
                "#ededed"
            ],
            3: generateBallColorArray(BALL_BASE_COLORS[2]),
            4: generateBallColorArray(BALL_BASE_COLORS[3]),
            5: generateBallColorArray(BALL_BASE_COLORS[4]),
            6: generateBallColorArray(BALL_BASE_COLORS[5]),
            7: generateBallColorArray(BALL_BASE_COLORS[6]),
            8: [
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#ededed",
                "#ededed",
                "#ededed",
                "#000000",
                "#ededed",
                "#ededed",
                "#ededed",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#ededed",
                "#ededed",
                "#ededed",
                "#000000",
                "#ededed",
                "#ededed",
                "#ededed",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#ededed",
                "#000000",
                "#ededed",
                "#ededed",
                "#ededed",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
                "#ededed",
                "#ededed",
                "#000000",
                "#ededed",
                "#ededed",
                "#ededed",
                "#000000",
                "#ededed",
                "#000000",
                "#000000",
                "#000000",
                "#000000",
            ],
            9: generateBallColorArray(BALL_BASE_COLORS[8]),
        }

        function generateBallColorArray(baseColor) {
            const count = 80
            const colors = []
            const baseRgb = hexToRgb(baseColor)

            for (let i = 0; i < count; i++) {
                // Apply small random deviation of +/- 10%
                const deviation = 0.9 + Math.random() * 0.2 // 0.9 to 1.1
                const r = Math.min(
                    255,
                    Math.max(0, Math.round(baseRgb.r * deviation))
                )
                const g = Math.min(
                    255,
                    Math.max(0, Math.round(baseRgb.g * deviation))
                )
                const b = Math.min(
                    255,
                    Math.max(0, Math.round(baseRgb.b * deviation))
                )
                colors.push(rgbToHex(r, g, b))
            }
            return colors
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)
            return result
                ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16),
                }
                : { r: 128, g: 128, b: 128 }
        }

        function rgbToHex(r, g, b) {
            return (
                "#" +
                ((1 << 24) + (r << 16) + (g << 8) + b)
                    .toString(16)
                    .slice(1)
                    .toUpperCase()
            )
        }

        // Application State - now uses array format
        const state = {
            mode: "rotate", // 'rotate' or 'paint'
            selectedColor: "#e94560",
            detailLevel: 1,
            colorArray: [], // Plain array format: [#FFFFFF, #FF0000, ...]
            hoveredFace: null,
            originalColor: null,
        }

        // Three.js globals
        let scene, camera, renderer, mesh, geometry, material
        let raycaster, mouse
        let isDragging = false
        let previousMousePosition = { x: 0, y: 0 }
        let cameraDistance = 10 // Increased default zoom distance
        let cameraTheta = 0
        let cameraPhi = Math.PI / 2

        // DOM Elements
        const container = document.getElementById("canvas-container")
        const rotateBtn = document.getElementById("rotate-btn")
        const paintBtn = document.getElementById("paint-btn")
        const colorPicker = document.getElementById("color-picker")
        const detailSlider = document.getElementById("detail-slider")
        const detailValue = document.getElementById("detail-value")
        const clearFillBtn = document.getElementById("clear-fill-btn")
        const modeIndicator = document.getElementById("mode-indicator")
        const devToggle = document.getElementById("dev-toggle")
        const devPanelOverlay = document.getElementById("dev-panel-overlay")
        const devPanelClose = document.getElementById("dev-panel-close")
        const triangleList = document.getElementById("triangle-list")
        const jsonState = document.getElementById("json-state")
        const zoomHint = document.getElementById("zoom-hint")
        const presetBtns = document.querySelectorAll(".preset-btn")

        // Initialize Three.js
        function init() {
            // Scene
            scene = new THREE.Scene()
            scene.background = new THREE.Color(0x1a1a2e)

            // Camera
            camera = new THREE.PerspectiveCamera(
                45,
                container.clientWidth / container.clientHeight,
                0.1,
                100
            )
            updateCameraPosition()

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true })
            renderer.setSize(container.clientWidth, container.clientHeight)
            renderer.setPixelRatio(window.devicePixelRatio)
            container.appendChild(renderer.domElement)

            // Raycaster
            raycaster = new THREE.Raycaster()
            mouse = new THREE.Vector2()

            // Create initial mesh
            createMesh()

            // Add lights - one point light far above, slightly to the right
            // Ambient light at 20% intensity
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2)
            scene.add(ambientLight)

            // Point light far above the ball, slightly to the right
            // Light stays in world space (doesn't rotate with ball)
            const pointLight = new THREE.PointLight(0xffffff, 1.0, 100)
            pointLight.position.set(3, 15, 0) // Far above (y=15), slightly right (x=3)
            scene.add(pointLight)

            // Create shadow and table cloth
            createTableAndShadow()

            // Event listeners
            setupEventListeners()

            // Load from URL
            loadFromURL()

            // Start render loop
            animate()

            // Show zoom hint briefly on load
            setTimeout(() => zoomHint.classList.add("visible"), 500)
            setTimeout(() => zoomHint.classList.remove("visible"), 4000)
        }

        function updateCameraPosition() {
            camera.position.x =
                cameraDistance * Math.sin(cameraPhi) * Math.cos(cameraTheta)
            camera.position.y = cameraDistance * Math.cos(cameraPhi)
            camera.position.z =
                cameraDistance * Math.sin(cameraPhi) * Math.sin(cameraTheta)
            camera.lookAt(0, 0, 0)
        }

        function createTableAndShadow() {
            const R = 2 // Ball radius

            // Create large blue table cloth first (at the bottom)
            const tableGeometry = new THREE.PlaneGeometry(50, 50)
            const tableMaterial = new THREE.MeshBasicMaterial({ color: 0x0a3d62 }) // Billiard table blue
            const table = new THREE.Mesh(tableGeometry, tableMaterial)
            table.rotation.x = -Math.PI / 2 // Lay flat on XZ plane
            table.position.y = -R - 2 // Well below the ball
            scene.add(table)

            // Create shadow just below the ball (not touching the table)
            const shadowGeometry = new THREE.CircleGeometry(R * 0.9, 32)
            const shadowMaterial = new THREE.MeshBasicMaterial({
                color: 0x111122,
                transparent: true,
                opacity: 0.7,
            })
            const shadow = new THREE.Mesh(shadowGeometry, shadowMaterial)
            shadow.rotation.x = -Math.PI / 2 // Lay flat on XZ plane
            shadow.position.y = -R + 0.1 // Just below the ball surface
            scene.add(shadow)

            // Add X, Y, Z axis arrows to show orientation
            createAxisArrows()
        }

        function createAxisArrows() {
            // X axis (Red) - Right
            const xArrow = createArrow(new THREE.Vector3(1, 0, 0), 0xff0000, "X")
            // Y axis (Green) - Up
            const yArrow = createArrow(new THREE.Vector3(0, 1, 0), 0x00ff00, "Y")
            // Z axis (Blue) - Forward
            const zArrow = createArrow(new THREE.Vector3(0, 0, 1), 0x0000ff, "Z")

            scene.add(xArrow)
            scene.add(yArrow)
            scene.add(zArrow)
        }

        function createArrow(direction, color) {
            const group = new THREE.Group()
            const arrowLength = 2.5
            const arrowHeadSize = 0.3

            // Shaft
            const shaftGeometry = new THREE.CylinderGeometry(
                0.05,
                0.05,
                arrowLength,
                8
            )
            shaftGeometry.translate(0, arrowLength / 2, 0)
            const shaftMaterial = new THREE.MeshBasicMaterial({
                color: color,
                opacity: 0.6,
            })
            const shaft = new THREE.Mesh(shaftGeometry, shaftMaterial)

            // Orient shaft along direction
            const axis = new THREE.Vector3(0, 1, 0)
            const quaternion = new THREE.Quaternion().setFromUnitVectors(
                axis,
                direction
            )
            shaft.setRotationFromQuaternion(quaternion)

            // Arrow head
            const headGeometry = new THREE.ConeGeometry(
                arrowHeadSize,
                arrowHeadSize * 2,
                8
            )
            headGeometry.translate(0, arrowLength + arrowHeadSize, 0)
            const headMaterial = new THREE.MeshBasicMaterial({ color: color })
            const head = new THREE.Mesh(headGeometry, headMaterial)
            head.setRotationFromQuaternion(quaternion)

            group.add(shaft)
            group.add(head)

            return group
        }

        function createMesh() {
            if (mesh) {
                scene.remove(mesh)
                geometry.dispose()
            }

            // Create icosahedron geometry with detail level
            geometry = new THREE.IcosahedronGeometry(2, state.detailLevel)

            // Set up vertex colors
            const count = geometry.attributes.position.count
            const colors = new Float32Array(count * 3)

            // Initialize with default color (gray)
            const defaultColor = new THREE.Color(0x888888)
            for (let i = 0; i < count; i++) {
                colors[i * 3] = defaultColor.r
                colors[i * 3 + 1] = defaultColor.g
                colors[i * 3 + 2] = defaultColor.b
            }

            geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3))

            // Apply stored colors from array format
            applyStoredColors()

            // Create material
            material = new THREE.MeshPhongMaterial({
                vertexColors: true,
                flatShading: true,
                emissive: 0,
                shininess: 25,
                specular: 0x555533,
                side: THREE.DoubleSide,
            })

            mesh = new THREE.Mesh(geometry, material)
            scene.add(mesh)

            updateDevPanel()
        }

        function applyStoredColors() {
            if (!geometry) return

            const colors = geometry.attributes.color.array
            const position = geometry.attributes.position

            // For each face (3 vertices per face in non-indexed geometry)
            const faceCount = position.count / 3

            for (let faceIndex = 0; faceIndex < faceCount; faceIndex++) {
                const colorHex = state.colorArray[faceIndex] || "#888888"
                const color = new THREE.Color(colorHex)

                // Set color for all 3 vertices of this face
                for (let v = 0; v < 3; v++) {
                    const idx = (faceIndex * 3 + v) * 3
                    colors[idx] = color.r
                    colors[idx + 1] = color.g
                    colors[idx + 2] = color.b
                }
            }

            geometry.attributes.color.needsUpdate = true
        }

        function paintFace(faceIndex, colorHex) {
            if (!geometry) return

            const colors = geometry.attributes.color.array
            const color = new THREE.Color(colorHex)

            // Set color for all 3 vertices of this face
            for (let v = 0; v < 3; v++) {
                const idx = (faceIndex * 3 + v) * 3
                colors[idx] = color.r
                colors[idx + 1] = color.g
                colors[idx + 2] = color.b
            }

            geometry.attributes.color.needsUpdate = true

            // Store in state as array
            state.colorArray[faceIndex] = colorHex

            updateDevPanel()
            updateURL()
        }

        function highlightFace(faceIndex) {
            if (!geometry || state.hoveredFace === faceIndex) return

            // Restore previous highlight
            if (state.hoveredFace !== null) {
                restoreFaceColor(state.hoveredFace)
            }

            state.hoveredFace = faceIndex

            if (faceIndex !== null) {
                const colors = geometry.attributes.color.array

                // Get current color and brighten it
                const r = colors[faceIndex * 9]
                const g = colors[faceIndex * 9 + 1]
                const b = colors[faceIndex * 9 + 2]

                const highlightColor = new THREE.Color(r, g, b).offsetHSL(0, 0, 0.3)

                // Apply highlight to all 3 vertices
                for (let v = 0; v < 3; v++) {
                    const idx = (faceIndex * 3 + v) * 3
                    colors[idx] = highlightColor.r
                    colors[idx + 1] = highlightColor.g
                    colors[idx + 2] = highlightColor.b
                }

                geometry.attributes.color.needsUpdate = true
            }
        }

        function restoreFaceColor(faceIndex) {
            if (!geometry || faceIndex === null) return

            const colors = geometry.attributes.color.array
            const colorHex = state.colorArray[faceIndex] || "#888888"
            const color = new THREE.Color(colorHex)

            for (let v = 0; v < 3; v++) {
                const idx = (faceIndex * 3 + v) * 3
                colors[idx] = color.r
                colors[idx + 1] = color.g
                colors[idx + 2] = color.b
            }

            geometry.attributes.color.needsUpdate = true
        }

        function getFaceIndex(intersect) {
            // In non-indexed geometry, each face has 3 vertices
            // faceIndex from raycaster is the triangle index
            return intersect.faceIndex
        }

        function setupEventListeners() {
            // Mode buttons
            rotateBtn.addEventListener("click", () => setMode("rotate"))
            paintBtn.addEventListener("click", () => setMode("paint"))

            // Color picker
            colorPicker.addEventListener("input", (e) => {
                state.selectedColor = e.target.value
            })

            // Detail slider
            detailSlider.addEventListener("input", (e) => {
                state.detailLevel = parseInt(e.target.value)
                detailValue.textContent = state.detailLevel
            })

            detailSlider.addEventListener("change", () => {
                // Clear colors when detail changes (face count changes)
                state.colorArray = []
                createMesh()
                updateURL()
            })

            // Clear/Fill button
            clearFillBtn.addEventListener("click", () => {
                const faceCount = geometry.attributes.position.count / 3
                for (let i = 0; i < faceCount; i++) {
                    state.colorArray[i] = state.selectedColor
                }
                applyStoredColors()
                updateDevPanel()
                updateURL()
            })

            // Dev panel toggle
            devToggle.addEventListener("click", () => {
                devPanelOverlay.classList.add("open")
            })

            // Dev panel close
            devPanelClose.addEventListener("click", () => {
                devPanelOverlay.classList.remove("open")
            })

            // Close dev panel when clicking overlay background
            devPanelOverlay.addEventListener("click", (e) => {
                if (e.target === devPanelOverlay) {
                    devPanelOverlay.classList.remove("open")
                }
            })

            // Preset buttons
            presetBtns.forEach((btn) => {
                btn.addEventListener("click", () => {
                    const ballNum = parseInt(btn.dataset.ball)
                    loadPreset(ballNum)
                })
            })

            // Canvas interactions
            renderer.domElement.addEventListener("mousedown", onMouseDown)
            renderer.domElement.addEventListener("mousemove", onMouseMove)
            renderer.domElement.addEventListener("mouseup", onMouseUp)
            renderer.domElement.addEventListener("click", onClick)
            renderer.domElement.addEventListener("touchstart", onTouchStart, {
                passive: false,
            })
            renderer.domElement.addEventListener("touchmove", onTouchMove, {
                passive: false,
            })
            renderer.domElement.addEventListener("touchend", onTouchEnd)
            renderer.domElement.addEventListener("wheel", onWheel, {
                passive: false,
            })

            // Window resize
            window.addEventListener("resize", onWindowResize)

            // Keyboard shortcut to close dev panel
            document.addEventListener("keydown", (e) => {
                if (
                    e.key === "Escape" &&
                    devPanelOverlay.classList.contains("open")
                ) {
                    devPanelOverlay.classList.remove("open")
                }
            })
        }

        function loadPreset(ballNum) {
            const preset = BALL_PRESETS[ballNum]
            if (!preset) return

            // Get current face count based on detail level
            const faceCount = geometry.attributes.position.count / 3

            // Copy preset colors, truncating or padding as needed
            state.colorArray = preset.slice(0, faceCount)

            // Pad with default color if preset is shorter
            while (state.colorArray.length < faceCount) {
                state.colorArray.push("#888888")
            }

            applyStoredColors()
            updateDevPanel()
            updateURL()
        }

        function setMode(mode) {
            state.mode = mode

            if (mode === "rotate") {
                rotateBtn.classList.add("active")
                paintBtn.classList.remove("active")
                modeIndicator.textContent = "Rotate Mode"
                modeIndicator.classList.remove("paint")
                renderer.domElement.style.cursor = "grab"
            } else {
                rotateBtn.classList.remove("active")
                paintBtn.classList.add("active")
                modeIndicator.textContent = "Paint Mode"
                modeIndicator.classList.add("paint")
                renderer.domElement.style.cursor = "crosshair"
            }

            // Clear any highlight
            if (state.hoveredFace !== null) {
                restoreFaceColor(state.hoveredFace)
                state.hoveredFace = null
            }
        }

        function updateMousePosition(clientX, clientY) {
            const rect = renderer.domElement.getBoundingClientRect()
            mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1
            mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1
        }

        function onMouseDown(event) {
            if (state.mode !== "rotate") return

            isDragging = true
            previousMousePosition = { x: event.clientX, y: event.clientY }
            renderer.domElement.style.cursor = "grabbing"
        }

        function onMouseMove(event) {
            updateMousePosition(event.clientX, event.clientY)

            if (state.mode === "rotate" && isDragging) {
                const deltaX = event.clientX - previousMousePosition.x
                const deltaY = event.clientY - previousMousePosition.y

                cameraTheta += deltaX * 0.01
                cameraPhi -= deltaY * 0.01
                cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi))

                updateCameraPosition()

                previousMousePosition = { x: event.clientX, y: event.clientY }
            } else if (state.mode === "paint") {
                // Hover highlight
                raycaster.setFromCamera(mouse, camera)
                const intersects = raycaster.intersectObject(mesh)

                if (intersects.length > 0) {
                    const faceIndex = getFaceIndex(intersects[0])
                    highlightFace(faceIndex)
                } else {
                    if (state.hoveredFace !== null) {
                        restoreFaceColor(state.hoveredFace)
                        state.hoveredFace = null
                    }
                }
            }
        }

        function onMouseUp() {
            isDragging = false
            if (state.mode === "rotate") {
                renderer.domElement.style.cursor = "grab"
            }
        }

        function onClick(event) {
            if (state.mode !== "paint") return

            updateMousePosition(event.clientX, event.clientY)
            raycaster.setFromCamera(mouse, camera)
            const intersects = raycaster.intersectObject(mesh)

            if (intersects.length > 0) {
                const faceIndex = getFaceIndex(intersects[0])
                paintFace(faceIndex, state.selectedColor)
            }
        }

        function onTouchStart(event) {
            if (event.touches.length === 1) {
                const touch = event.touches[0]
                updateMousePosition(touch.clientX, touch.clientY)

                if (state.mode === "rotate") {
                    isDragging = true
                    previousMousePosition = { x: touch.clientX, y: touch.clientY }
                }
            }
        }

        function onTouchMove(event) {
            if (event.touches.length === 1) {
                event.preventDefault()
                const touch = event.touches[0]
                updateMousePosition(touch.clientX, touch.clientY)

                if (state.mode === "rotate" && isDragging) {
                    const deltaX = touch.clientX - previousMousePosition.x
                    const deltaY = touch.clientY - previousMousePosition.y

                    cameraTheta += deltaX * 0.01
                    cameraPhi -= deltaY * 0.01
                    cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi))

                    updateCameraPosition()

                    previousMousePosition = { x: touch.clientX, y: touch.clientY }
                }
            }
        }

        function onTouchEnd(event) {
            if (state.mode === "paint" && event.changedTouches.length === 1) {
                const touch = event.changedTouches[0]
                updateMousePosition(touch.clientX, touch.clientY)
                raycaster.setFromCamera(mouse, camera)
                const intersects = raycaster.intersectObject(mesh)

                if (intersects.length > 0) {
                    const faceIndex = getFaceIndex(intersects[0])
                    paintFace(faceIndex, state.selectedColor)
                }
            }
            isDragging = false
        }

        function onWindowResize() {
            camera.aspect = container.clientWidth / container.clientHeight
            camera.updateProjectionMatrix()
            renderer.setSize(container.clientWidth, container.clientHeight)
        }

        function onWheel(event) {
            event.preventDefault()
            const zoomSpeed = 0.001
            cameraDistance += event.deltaY * zoomSpeed
            cameraDistance = Math.max(3, Math.min(15, cameraDistance))
            updateCameraPosition()
        }

        function updateDevPanel() {
            // Update triangle list
            let listHTML = ""

            for (let i = 0; i < state.colorArray.length; i++) {
                const color = state.colorArray[i]
                if (color && color !== "#888888") {
                    listHTML += `
                        <div class="entry">
                            <span>Face ${i}</span>
                            <span style="color: ${color}">${color}</span>
                        </div>
                    `
                }
            }

            if (listHTML === "") {
                listHTML =
                    '<div class="entry"><span>No painted triangles</span></div>'
            }

            triangleList.innerHTML = listHTML

            // Update color array display
            jsonState.value = JSON.stringify(state.colorArray, null, 2)
        }

        function updateURL() {
            const stateObj = {
                d: state.detailLevel,
                c: state.colorArray,
            }

            const jsonStr = JSON.stringify(stateObj)
            const encoded = btoa(jsonStr)

            const newURL = new URL(window.location.href)
            newURL.searchParams.set("s", encoded)
            window.history.replaceState({}, "", newURL)
        }

        function loadFromURL() {
            const urlParams = new URLSearchParams(window.location.search)
            const encoded = urlParams.get("s")

            if (encoded) {
                try {
                    const jsonStr = atob(encoded)
                    const stateObj = JSON.parse(jsonStr)

                    if (stateObj.d !== undefined) {
                        state.detailLevel = stateObj.d
                        detailSlider.value = state.detailLevel
                        detailValue.textContent = state.detailLevel
                    }

                    if (stateObj.c && Array.isArray(stateObj.c)) {
                        state.colorArray = stateObj.c
                    } else if (stateObj.c && typeof stateObj.c === "object") {
                        // Handle legacy object format { faceIndex: color }
                        const maxIndex = Math.max(
                            ...Object.keys(stateObj.c).map(Number),
                            -1
                        )
                        state.colorArray = new Array(maxIndex + 1).fill("#888888")
                        for (const [idx, color] of Object.entries(stateObj.c)) {
                            state.colorArray[parseInt(idx)] = color
                        }
                    }

                    createMesh()
                } catch (e) {
                    console.error("Failed to load state from URL:", e)
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate)
            renderer.render(scene, camera)
        }

        // Initialize on load
        init()
    </script>
</body>

</html>